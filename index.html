<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI & ML Lab Programs</title>
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
    
    <!-- PrismJS for Syntax Highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    
    <style>
        :root {
            /* Dark Theme (Permanent) */
            --primary: #3b82f6;
            /* Slightly lighter blue for dark mode contrast */
            --primary-hover: #2563eb;
            --bg-color: #0f172a;
            --card-bg: #1e293b;
            --text-main: #f1f5f9;
            --text-muted: #94a3b8;
            --border-color: #334155;
            --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.3);
            --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.5);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.5);
            --radius: 12px;
            --select-bg: #1e293b;
            --toggle-hover: #334155;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-main);
            line-height: 1.5;
            padding: 2rem;
            min-height: 100vh;
            display: flex;
            justify-content: center;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        .container {
            width: 100%;
            max-width: 1000px;
            margin: 0 auto;
        }

        /* Header */
        header {
            margin-bottom: 3rem;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        h1 {
            font-size: 2.5rem;
            font-weight: 800;
            margin-bottom: 0.5rem;
            background: linear-gradient(135deg, var(--text-main) 0%, var(--text-muted) 100%);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: -0.025em;
        }

        .subtitle {
            color: var(--text-muted);
            font-size: 1.125rem;
        }

        /* Controls */
        .controls {
            background: var(--card-bg);
            padding: 2rem;
            border-radius: var(--radius);
            box-shadow: var(--shadow-sm);
            margin-bottom: 2rem;
            border: 1px solid var(--border-color);
            transition: background-color 0.3s ease, border-color 0.3s ease;
        }

        label {
            display: block;
            margin-bottom: 0.75rem;
            font-weight: 600;
            color: var(--text-main);
        }

        .select-wrapper {
            position: relative;
        }

        select {
            width: 100%;
            appearance: none;
            background-color: var(--select-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            font-size: 1rem;
            font-family: inherit;
            color: var(--text-main);
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: var(--shadow-sm);
        }

        select:hover {
            border-color: var(--text-muted);
        }

        select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .select-arrow {
            position: absolute;
            right: 1rem;
            top: 50%;
            transform: translateY(-50%);
            pointer-events: none;
            color: var(--text-muted);
        }

        /* Display Area */
        #display-area {
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.4s ease, transform 0.4s ease;
        }

        #display-area.visible {
            opacity: 1;
            transform: translateY(0);
        }

        #display-area h2 {
            font-size: 1.5rem;
            margin-bottom: 1rem;
            font-weight: 700;
        }

        .code-container {
            background: #2d2d2d;
            /* Match Prism Tomorrow theme bg roughly */
            border-radius: var(--radius);
            overflow: hidden;
            box-shadow: var(--shadow-lg);
            position: relative;
        }

        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .lang-tag {
            font-family: 'Fira Code', monospace;
            font-size: 0.875rem;
            color: #94a3b8;
            font-weight: 500;
        }

        .copy-btn {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: #fff;
            padding: 0.5rem 0.875rem;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.2s;
            font-family: inherit;
        }

        .copy-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .copy-btn:active {
            transform: scale(0.96);
        }

        .code-scroll {
            overflow-x: auto;
            padding: 0;
            /* Removed max-height to allow full page scroll */
        }

        /* Override Prism defaults for better fit */
        pre[class*="language-"] {
            margin: 0 !important;
            border-radius: 0 !important;
            padding: 1.5rem 1.5rem 1.5rem 6rem !important;
            font-family: 'Fira Code', monospace !important;
            font-size: 0.925rem;
            line-height: 1.6;
            counter-reset: line;
            position: relative;
        }

        /* Line numbering gutter */
        pre[class*="language-"] code {
            display: block;
        }

        pre[class*="language-"] code .token-line,
        pre[class*="language-"] code > span {
            counter-increment: line;
            position: relative;
            display: inline;
        }

        pre[class*="language-"] code .token-line::before,
        pre[class*="language-"] code > span::before {
            content: counter(line);
            position: absolute;
            left: -7.0rem;
            width: 2.5rem;
            text-align: right;
            color: rgba(148, 163, 184, 0.4);
            font-size: 0.875rem;
            user-select: none;
            pointer-events: none;
        }

        /* For plain text without spans, add line numbers to each line */
        pre[class*="language-"]:not(:has(code > span)) code::before {
            content: '';
            position: absolute;
            left: 1.5rem;
            top: 1.5rem;
            width: 2.5rem;
            height: 100%;
            text-align: right;
            color: rgba(148, 163, 184, 0.4);
            font-size: 0.875rem;
            user-select: none;
            pointer-events: none;
            white-space: pre;
            counter-reset: line;
        }

        footer {
            text-align: center;
            margin-top: 4rem;
            color: var(--text-muted);
            font-size: 0.875rem;
        }

        @media (max-width: 640px) {
            body {
                padding: 1rem;
            }

            h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>

    <div class="container">
        <header>
            <div class="header-content">
                <div class="title-section">
                    <h1>AI & ML Lab Programs</h1>
                    <p class="subtitle">Select a program to view the source code</p>
                </div>
            </div>
        </header>

        <section class="controls">
            <label for="program-select">Select the program to display:</label>
            <div class="select-wrapper">
                <select id="program-select">
                    <option value="" disabled selected>Select a program...</option>
                    <!-- Options will be populated by JS -->
                </select>
                <div class="select-arrow">
                    <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </div>
            </div>
        </section>

        <main id="display-area" class="hidden">
            <h2 id="program-title">Program Name</h2>
            
            <div class="code-container">
                <div class="code-header">
                    <span class="lang-tag">Python</span>
                    <button id="copy-btn" class="copy-btn">
                        <span class="icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                        </span>
                        Copy Code
                    </button>
                </div>
                <div class="code-scroll">
                    <pre><code id="code-block" class="language-python"># Code will appear here</code></pre>
                </div>
            </div>
        </main>
        
        <footer>
            <p>Generated by Antigravity</p>
        </footer>
    </div>

    <!-- PrismJS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    
    <!-- Embedded Program Data -->
    <script>
        const programs = {"ASTARALGORITHM.py": "import heapq\n\n# Possible moves: up, down, left, right\nMOVES = [(-1,0), (1,0), (0,-1), (0,1)]\n\n\ndef print_state(state):\n    for row in state:\n        print(\" \".join(map(str, row)))\n    print()\n\n\ndef heuristic(state, goal):\n    # Misplaced tiles heuristic (ignore blank = 0)\n    count = 0\n    for i in range(3):\n        for j in range(3):\n            if state[i][j] != 0:\n                if state[i][j] != goal[i][j]:\n                    count += 1\n    return count\n\n\ndef find_blank(state):\n    for i in range(3):\n        for j in range(3):\n            if state[i][j] == 0:\n                return i, j\n\n\ndef get_neighbors(state):\n    x, y = find_blank(state)\n    neighbors = []\n\n    for dx, dy in MOVES:\n        nx, ny = x + dx, y + dy\n        if 0 <= nx < 3 and 0 <= ny < 3:\n            new_state = [list(row) for row in state]\n            new_state[x][y], new_state[nx][ny] = new_state[nx][ny], new_state[x][y]\n            neighbors.append(tuple(tuple(row) for row in new_state))\n\n    return neighbors\n\n\ndef a_star(start, goal):\n    start = tuple(tuple(row) for row in start)\n    goal = tuple(tuple(row) for row in goal)\n\n    open_list = []\n    heapq.heappush(open_list, (heuristic(start, goal), 0, start))\n    closed = set()\n\n    parent = {start: None}\n    g_score = {start: 0}  # Track g-scores separately\n\n    while open_list:\n        f, g, current = heapq.heappop(open_list)\n\n        if current == goal:\n            # Reconstruct path\n            path = []\n            while current:\n                path.append(current)\n                current = parent[current]\n            path.reverse()\n\n            print(\"Solution path:\\n\")\n            for step in path:\n                print_state(step)\n\n            print(\"Total moves:\", len(path) - 1)\n            return\n\n        closed.add(current)\n\n        for neighbor in get_neighbors(current):\n            if neighbor in closed:\n                continue\n\n            g_new = g + 1\n\n            # If we found a better path to this neighbor\n            if neighbor not in g_score or g_new < g_score[neighbor]:\n                parent[neighbor] = current\n                g_score[neighbor] = g_new\n                f_new = g_new + heuristic(neighbor, goal)\n                heapq.heappush(open_list, (f_new, g_new, neighbor))\n\n    print(\"No solution found\")\n\n\ninitial_state = [\n    [1, 2, 3],\n    [8, 0, 4],\n    [7, 6, 5]\n]\n\ngoal_state = [\n    [2, 8, 1],\n    [0, 4, 3],\n    [7, 6, 5]\n]\n\na_star(initial_state, goal_state)\n", "HillClimb.py": "def hill_climbing(func, start, step=0.01, max_iter=1000):\n    x = start\n\n    for _ in range(max_iter):\n        f_x = func(x)\n        f_right = func(x + step)\n        f_left = func(x - step)\n\n        if f_right > f_x and f_right >= f_left:\n            x += step\n        elif f_left > f_x:\n            x -= step\n        else:\n            break\n\n    return x, func(x)\n\n\n# ---- User input ----\nwhile True:\n    try:\n        func_str = input(\"\\nEnter a function of x: \")\n        func = lambda x: eval(func_str)\n        func(0)   # test\n        break\n    except:\n        print(\"Invalid function. Try again.\")\n\nwhile True:\n    try:\n        start = float(input(\"\\nEnter starting value: \"))\n        break\n    except:\n        print(\"Enter a valid number.\")\n\nmaxima, max_value = hill_climbing(func, start)\n\nprint(\"The maxima is at x =\", maxima)\nprint(\"The maximum value obtained is\", max_value)\n", "Kmeans.py": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.datasets import load_iris\n\niris = load_iris()\nX = iris.data\n\ndef kmeans(X, k):\n    centroids = X[np.random.choice(X.shape[0], k, replace=False)]\n\n    for _ in range(100):\n        distances = np.linalg.norm(X[:, None] - centroids, axis=2)\n        labels = np.argmin(distances, axis=1)\n        centroids = np.array([X[labels == i].mean(axis=0) for i in range(k)])\n\n    return centroids, labels\n\nk = 3\ncentroids, labels = kmeans(X, k)\n\ncolors = ['r', 'g', 'b']\n\nfor i in range(k):\n    plt.scatter(X[labels == i, 0], X[labels == i, 1], c=colors[i], label=f'Cluster {i+1}')\n\nplt.scatter(centroids[:, 0], centroids[:, 1], marker='x', c='black', label='Centroids')\n\nplt.title('K-Means Clustering on Iris Dataset')\nplt.xlabel('Sepal Length')\nplt.ylabel('Sepal Width')\nplt.legend()\nplt.show()\n", "KNN.py": "import numpy as np\nfrom sklearn.datasets import load_iris\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import confusion_matrix, classification_report\nfrom collections import Counter\n\niris = load_iris()\nX, y = iris.data, iris.target\nclass_names = iris.target_names\n\nXtr, Xte, ytr, yte = train_test_split(X, y, test_size=0.3, random_state=1)\n\ndef knn_predict(Xtr, ytr, Xte, k=3):\n    preds = []\n    for x in Xte:\n        dists = np.linalg.norm(Xtr - x, axis=1)\n        k_labels = ytr[np.argsort(dists)[:k]]\n        preds.append(Counter(k_labels).most_common(1)[0][0])\n    return np.array(preds)\n\ny_pred = knn_predict(Xtr, ytr, Xte, k=3)\n\nprint(\"Accuracy: %.4f\" % np.mean(y_pred == yte))\nprint(\"Predictions:\", class_names[y_pred])\nprint(\"\\nConfusion Matrix:\")\nprint(confusion_matrix(yte, y_pred))\nprint(\"\\nClassification Report:\")\nprint(classification_report(yte, y_pred))\n", "LogisticRegression.py": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.datasets import load_iris\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\n\n\n# Sigmoid\ndef sigmoid(z):\n    return 1 / (1 + np.exp(-z))\n\n\n# Logistic Regression\ndef train(X, y, lr=0.001, iters=200):\n    w = np.zeros(X.shape[1])\n    for _ in range(iters):\n        w -= lr * (X.T @ (sigmoid(X @ w) - y)) / len(y)\n    return w\n\n\n# Load data\niris = load_iris()\nX = iris.data[:, :2]    \ny = (iris.target != 0).astype(int)\n\n# Split & scale\nXtr, Xte, ytr, yte = train_test_split(X, y, test_size=0.4, random_state=9)\nsc = StandardScaler()\nXtr = sc.fit_transform(Xtr)\nXte = sc.transform(Xte)\n\n# Train\nw = train(Xtr, ytr)\n\n# Accuracy\npred = sigmoid(Xte @ w) > 0.5\nprint(\"Accuracy:\", np.mean(pred == yte))\n\n# Plot decision boundary\nxx, yy = np.meshgrid(\n    np.arange(Xtr[:,0].min()-1, Xtr[:,0].max()+1, 0.1),\n    np.arange(Xtr[:,1].min()-1, Xtr[:,1].max()+1, 0.1)\n)\n\nZ = sigmoid(np.c_[xx.ravel(), yy.ravel()] @ w) > 0.5\nplt.contourf(xx, yy, Z.reshape(xx.shape), alpha=0.4)\nplt.scatter(Xtr[:,0], Xtr[:,1], c=ytr)\nplt.xlabel(\"Sepal length\")\nplt.ylabel(\"Sepal width\")\nplt.title(\"Logistic Regression\")\nplt.show()\n", "MINMAX.py": "INF = 1000\n\ndef minimax(depth, index, is_max, values, alpha, beta):\n    # Leaf node\n    if depth == 3:\n        return values[index]\n\n    # MAX player's turn\n    if is_max:\n        best = -INF\n        for child in range(2):\n            value = minimax(depth + 1, index * 2 + child,\n                            False, values, alpha, beta)\n            best = max(best, value)\n            alpha = max(alpha, best)\n\n            if beta <= alpha:   # pruning\n                break\n        return best\n\n    # MIN player's turn\n    else:\n        best = INF\n        for child in range(2):\n            value = minimax(depth + 1, index * 2 + child,\n                            True, values, alpha, beta)\n            best = min(best, value)\n            beta = min(beta, best)\n\n            if beta <= alpha:   # pruning\n                break\n        return best\n\n\nvalues = [3, 5, 6, 9, 1, 2, 0, -1]\nprint(\"Optimal value:\", minimax(0, 0, True, values, -INF, INF))\n", "NaiveBayes.py": "import numpy as np\nfrom sklearn.datasets import load_iris\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import confusion_matrix, classification_report\n\niris = load_iris()\nX, y = iris.data, iris.target\n\nclass NaiveBayes:\n    def fit(self, X, y):\n        self.classes = np.unique(y)\n        self.mean = np.array([X[y == c].mean(0) for c in self.classes])\n        self.var = np.array([X[y == c].var(0) for c in self.classes])\n        self.priors = np.array([np.mean(y == c) for c in self.classes])\n\n    def predict(self, X):\n        return np.array([self._predict(x) for x in X])\n\n    def _predict(self, x):\n        probs = []\n        for i in range(len(self.classes)):\n            likelihood = -0.5 * np.sum(np.log(2 * np.pi * self.var[i]))\n            likelihood -= np.sum((x - self.mean[i]) ** 2 / (2 * self.var[i]))\n            probs.append(np.log(self.priors[i]) + likelihood)\n        return self.classes[np.argmax(probs)]\n\nXtr, Xte, ytr, yte = train_test_split(X, y, test_size=0.3, random_state=1)\n\nnb = NaiveBayes()\nnb.fit(Xtr, ytr)\n\ny_pred = nb.predict(Xte)\n\nprint(\"Accuracy: %.4f\" % np.mean(y_pred == yte))\nprint(\"Predictions:\", iris.target_names[y_pred])\nprint(\"\\nConfusion Matrix:\")\nprint(confusion_matrix(yte, y_pred))\nprint(\"\\nClassification Report:\")\nprint(classification_report(yte, y_pred, target_names=iris.target_names))\n    ", "TicTacToe.py": "class TicTacToe: \n    def __init__(self): \n        self.board = [[' ']*3 for _ in range(3)] \n        self.player = 'X' \n \n    def print_board(self): \n        for row in self.board: \n            print(' | '.join(row)) \n        print('-' * 5) \n \n    def is_winner(self, player): \n        for row in self.board: \n            if row.count(player) == 3: \n                return True \n        for col in zip(*self.board): \n            if list(col).count(player) == 3: \n                return True \n        if all(self.board[i][i] == player for i in range(3)) or all(self.board[i][2-i] == player for i in \nrange(3)): \n            return True \n        return False \n \n    def is_draw(self): \n        return all(cell != ' ' for row in self.board for cell in row) \n \n    def dfs(self, player): \n        winner = 'X' if self.is_winner('X') else ('O' if self.is_winner('O') else None) \n        if winner: \n            return {'score': 1 if winner == 'X' else -1} \n        if self.is_draw(): \n            return {'score': 0} \n \n        best = {'score': -float('inf')} if player == 'X' else {'score': float('inf')} \n        for i in range(3): \n            for j in range(3): \n                if self.board[i][j] == ' ': \n                    self.board[i][j] = player \n                    score = self.dfs('O' if player == 'X' else 'X') \n                    self.board[i][j] = ' ' \n                    score['row'], score['col'] = i, j \n \n                    if player == 'X' and score['score'] > best['score']: \n                        best = score \n                    elif player == 'O' and score['score'] < best['score']: \n                        best = score \n        return best \n \n    def play(self): \n        while True: \n            self.print_board() \n            if self.is_winner('X'): \n                print(\"Player X wins!\") \n                break \n            if self.is_winner('O'): \n                print(\"Player O wins!\") \n                break \n            if self.is_draw(): \n                print(\"It's a draw!\") \n                break \n            if self.player == 'X': \n                best_move = self.dfs('X') \n                self.board[best_move['row']][best_move['col']] = 'X' \n            else: \n                while True: \n                    try: \n                        i, j = map(int, input(\"Enter row and column (0-2): \").split()) \n                        if self.board[i][j] == ' ': \n                            self.board[i][j] = 'O' \n                            break \n                        else: \n                            print(\"Invalid move. Try again.\") \n                    except (ValueError, IndexError): \n                        print(\"Enter valid numbers between 0 and 2.\") \n            self.player = 'O' if self.player == 'X' else 'X' \n \ngame = TicTacToe() \ngame.play()", "LogisticRegressionSklearn.py": "import numpy as np\nimport matplotlib.pyplot as plt\n\nfrom sklearn.datasets import load_iris\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.inspection import DecisionBoundaryDisplay\n\n\n# Load data\niris = load_iris()\nX = iris.data[:, :2]\ny = (iris.target != 0).astype(int)\n\n# Split\nXtr, Xte, ytr, yte = train_test_split(X, y, test_size=0.4, random_state=9)\n\n# Scale\nsc = StandardScaler()\nXtr = sc.fit_transform(Xtr)\nXte = sc.transform(Xte)\n\n# Train\nlr = LogisticRegression()\nlr.fit(Xtr, ytr)\n\n# Accuracy\nprint(\"Accuracy:\", np.mean(lr.predict(Xte) == yte))\n\n# Plot decision boundary\nDecisionBoundaryDisplay.from_estimator(lr, Xtr, response_method=\"predict\", alpha=0.3)\nplt.scatter(Xtr[:,0], Xtr[:,1], c=ytr, edgecolor=\"k\")\nplt.xlabel(\"Sepal Length (scaled)\")\nplt.ylabel(\"Sepal Width (scaled)\")\nplt.title(\"Logistic Regression Decision Boundary\")\nplt.show()", "NaiveBayesSklearn.py": "import numpy as np\nfrom sklearn.datasets import load_iris\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.metrics import accuracy_score, confusion_matrix, classification_report\n\niris = load_iris()\nX, y = iris.data, iris.target\n\nXtr, Xte, ytr, yte = train_test_split(X, y, test_size=0.3, random_state=1)\n\nnb = GaussianNB()\nnb.fit(Xtr, ytr)\n\ny_pred = nb.predict(Xte)\n\nprint(\"Accuracy: %.4f\" % accuracy_score(yte, y_pred))\nprint(\"Predictions:\", iris.target_names[y_pred])\nprint(\"\\nConfusion Matrix:\\n\", confusion_matrix(yte, y_pred))\nprint(\"\\nClassification Report:\\n\", classification_report(yte, y_pred, target_names=iris.target_names))\n", "KNNSklearn.py": "import numpy as np\nfrom sklearn.datasets import load_iris\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.metrics import accuracy_score, confusion_matrix, classification_report\n\niris = load_iris()\nX, y = iris.data, iris.target\nclass_names = iris.target_names\n\nXtr, Xte, ytr, yte = train_test_split(X, y, test_size=0.3, random_state=1)\n\nknn = KNeighborsClassifier(n_neighbors=3)\nknn.fit(Xtr, ytr)\n\ny_pred = knn.predict(Xte)\n\nprint(\"Accuracy: %.4f\" % accuracy_score(yte, y_pred))\nprint(\"Predictions:\", class_names[y_pred])\nprint(\"\\nConfusion Matrix:\\n\", confusion_matrix(yte, y_pred))\nprint(\"\\nClassification Report:\\n\", classification_report(yte, y_pred, target_names=class_names))\n", "KmeansSklearn.py": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.datasets import load_iris\nfrom sklearn.cluster import KMeans\n\niris = load_iris()\nX = iris.data\n\nkmeans = KMeans(n_clusters=3, random_state=42, n_init=10)\nlabels = kmeans.fit_predict(X)\ncentroids = kmeans.cluster_centers_\n\ncolors = ['r','g','b']\n\nfor i in range(3): plt.scatter(X[labels==i,0], X[labels==i,1], c=colors[i], label=f'Cluster {i+1}')\nplt.scatter(centroids[:,0], centroids[:,1], c='black', marker='x', s=100, label='Centroids')\nplt.xlabel('Sepal Length'); plt.ylabel('Sepal Width'); plt.title('K-Means Clustering on Iris Dataset')\nplt.legend(); plt.show()\n"};

    </script>
    
    <!-- App Logic -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const programSelect = document.getElementById('program-select');
            const displayArea = document.getElementById('display-area');
            const programTitle = document.getElementById('program-title');
            const codeBlock = document.getElementById('code-block');
            const copyBtn = document.getElementById('copy-btn');
            const copyBtnText = copyBtn.innerText;

            // 1. Populate Dropdown
            // Ensure 'programs' is defined (loaded from programs.js)
            if (typeof programs === 'undefined') {
                console.error('Programs data not loaded!');
                programSelect.innerHTML = '<option disabled>Error: Programs data missing</option>';
                return;
            }

            // Define the desired order and display names
            const programConfig = [
                { file: 'TicTacToe.py', name: '1. Tic Tac Toe' },
                { file: 'MINMAX.py', name: '2. Alpha Beta Pruning' },
                { file: 'ASTARALGORITHM.py', name: '3. 8 Puzzle (A* Algorithm)' },
                { file: 'HillClimb.py', name: '4. Hill Climbing' },
                { file: 'LogisticRegression.py', name: '5. Logistic Regression' },
                { file: 'NaiveBayes.py', name: '6. Naive Bayes' },
                { file: 'KNN.py', name: '7. K-Nearest Neighbors' },
                { file: 'Kmeans.py', name: '8. K-Means Clustering' },
                { file: 'LogisticRegressionSklearn.py', name: '9. Logistic Regression (sklearn)' },
                { file: 'NaiveBayesSklearn.py', name: '10. Naive Bayes (sklearn)' },
                { file: 'KNNSklearn.py', name: '11. KNN (sklearn)' },
                { file: 'KmeansSklearn.py', name: '12. K-Means (sklearn)' }
            ];

            // Get available files from programs.js
            const availableFiles = Object.keys(programs);

            // Filter to get only files that exist in our config and in the available files
            // This allows us to strictly follow the user's order
            const orderedFiles = programConfig.filter(item => availableFiles.includes(item.file));

            // Also find any files that are available but NOT in our config, just in case
            const otherFiles = availableFiles
                .filter(file => !programConfig.find(item => item.file === file))
                .sort()
                .map(file => ({ file: file, name: file.replace('.py', '') }));

            // Merge them
            const allItems = [...orderedFiles, ...otherFiles];

            allItems.forEach(item => {
                const option = document.createElement('option');
                option.value = item.file;
                option.textContent = item.name;
                programSelect.appendChild(option);
            });

            // 2. Handle Selection Change
            programSelect.addEventListener('change', (e) => {
                const filename = e.target.value;
                const code = programs[filename];

                if (code) {
                    // Update Title
                    programTitle.textContent = filename.replace('.py', '');

                    // Update Code
                    // Escape HTML entities just in case, though Prism usually handles raw text in <code> well 
                    // but setting textContent is safer than innerHTML
                    codeBlock.textContent = code;

                    // Trigger Syntax Highlight
                    Prism.highlightElement(codeBlock);

                    // Wrap each line in a span for line numbering
                    const lines = codeBlock.innerHTML.split('\n');
                    codeBlock.innerHTML = lines.map(line => `<span class="token-line">${line}\n</span>`).join('');

                    // Show Display Area
                    displayArea.classList.remove('hidden');
                    // Small timeout to allow removing hidden to apply first if using display:none (css uses opacity)
                    // If using pure CSS class for opacity:
                    requestAnimationFrame(() => {
                        displayArea.classList.add('visible');
                    });
                }
            });

            // 3. Copy Functionality
            copyBtn.addEventListener('click', async () => {
                const codeText = codeBlock.textContent;

                try {
                    await navigator.clipboard.writeText(codeText);

                    // Visual Feedback
                    copyBtn.innerHTML = `
                        <span class="icon">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>
                        </span>
                        Copied!
                    `;
                    copyBtn.style.background = 'rgba(16, 185, 129, 0.2)'; // Green tint
                    copyBtn.style.color = '#34d399';

                    setTimeout(() => {
                        // Revert
                        copyBtn.innerText = 'Copy Code';
                        // Note: InnerText removes the icon HTML, so we need to put it back or just reset HTML
                        copyBtn.innerHTML = `
                            <span class="icon">
                                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>
                            </span>
                            Copy Code
                        `;
                        copyBtn.style.background = '';
                        copyBtn.style.color = '';
                    }, 2000);

                } catch (err) {
                    console.error('Failed to copy!', err);
                    alert('Failed to copy to clipboard');
                }
            });
        });
    </script>
</body>
</html>
